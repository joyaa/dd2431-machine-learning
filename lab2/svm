from cvxopt.solvers import qp
from cvxopt.base import matrix

import numpy as np, pylab, random, math

def main(kernelType):
	
	data = generateData()
	P = buildMatrix(data)
	qhG = createVectors(len(P)) #vectors q & h, matrix G

	r = qp(matrix(P), matrix(qhG[0]), matrix(qhG[2]), matrix(qhG[1]))
	alpha = list(r['x'])	

	global nonzeroAlphas 
	nonzeroAlphas = nonzero(alpha, data)

	boundaryPlot()

def indicator(x, y):
	Sum = 0
	for point in nonzeroAlphas:
		Sum += point[3]*point[2]*kernel((x, y),(point[0], point[1]))
	return Sum

def nonzero(alphaList, datapoints):
	nonzeros = []
	
	i = 0
	for alpha in alphaList:
		if alpha > 1e-5:
			print(datapoints[i])
			print(alpha)
			nonzeros.append(datapoints[i] + (alpha,))
		i += 1
	return nonzeros

def kernel(x, y): #takes two vectors x and y
	#if k == 1:
	return np.dot(x, y) + 1 #add 1 for bias

def createVectors(length):
	q = -np.ones(length)
	h = np.ones(length)
	G = -np.identity(length)
	return [q,h,G]

def generateData():
	#normalvariate(mean, standard deviation)
	classA = 	[(random.normalvariate(-1.5, 1),
				  random.normalvariate(0.5, 1),
				  1.0)
				 for i in range(5)] + \
				[(random.normalvariate(1.5, 1),
				  random.normalvariate(0.5, 1),
				  1.0)
				for i in range(5)]

	classB = 	[(random.normalvariate(0.0, 0.5),
		  		  random.normalvariate(-0.5, 0.5),
				  -1.0)
			 	for i in range(10)]
	
	tempData = classA + classB
	random.shuffle(tempData)

	#plotData(classA, classB)

	return tempData

def plotData(classA,classB):

	pylab.hold(True)
	pylab.plot( [p[0] for p in classA],
				[p[1] for p in classA],
				'bo')

	pylab.plot( [p[0] for p in classB],
				[p[1] for p in classB],
				'ro')
	#pylab.show()


def buildMatrix(data):
	tempP = np.zeros(shape=(len(data),len(data)))
	i=0

	for x in data:
		j=0

		for y in data: 
						
			tempP[i,j] = x[2]*y[2]*kernel((x[0], x[1]), (y[0], y[1]))
			j += 1
		
		i += 1	

	return tempP


def boundaryPlot():



	xrange = np.arange(-4, 4, 0.05)
	yrange = np.arange(-4, 4, 0.05)

	grid = matrix([[indicator(x, y)
					for y in yrange]
				    for x in xrange])

	pylab.contour(xrange, yrange, grid, 
					(-1.0, 0.0, 1.0), 
					colors=('red', 'black', 'blue'),
					linewidths=(1,3,1))
	pylab.show()

k = raw_input("Choose kernel type 1: Linear, 2: Polynomial, 3: Radial Basis, 4: Sigmoid \n")
main(k)