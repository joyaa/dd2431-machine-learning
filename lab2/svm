from cvxopt.solvers import qp
from cvxopt.base import matrix

import numpy as np, pylab, random, math

def kernel_linear(x, y): #takes two vectors x and y
	return np.dot(x, y) + 1 #add 1 for bias


def generateData():
	#normalvariate(mean, standard deviation)
	classA = 	[(random.normalvariate(-1.5, 1),
				  random.normalvariate(0.5, 1),
				  1.0)
				 for i in range(5)] + \
				[(random.normalvariate(1.5, 1),
				  random.normalvariate(0.5, 1),
				  1.0)
				for i in range(5)]

	classB = 	[(random.normalvariate(0.0, 0.5),
		  		  random.normalvariate(-0.5, 0.5),
				  -1.0)
			 	for i in range(10)]
	
	data = classA + classB
	random.shuffle(data)
	return data

def buildMatrix(data):
	P = np.matrix()
	i=0

	for x in data:
		j=0
		for y in data: 
			P[i,j] = x[2]*y[2]*kernel_linear(x, y)
			j+=1
		i+=1	

		
#plotting test data
def plotData():
	pylab.hold(True)
	pylab.plot( [p[0] for p in classA],
				[p[1] for p in classA],
				'bo')

	pylab.plot( [p[0] for p in classB],
				[p[1] for p in classB],
				'ro')
	pylab.show()

def boundaryPlot():
	xrange = numpy.arange(-4, 4, 0.05)
	yrange = numpy.arange(-4, 4, 0.05)

	grid = matrix([[indicator(x, y)
					for y in yrange]
				   for x in xrange])

	pylab.contour(xrange, yrange, grid, 
					(-1.0, 0.0, 1.0), 
					colors=('red', 'black', 'blue'),
					linewidths=(1,3,1))

